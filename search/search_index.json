{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hlb is a high-level build language for BuildKit . Describe your build in containerized units of work, and BuildKit will build your target as efficiently as possible. Key features \u00b6 Efficient, expressive, and repeatable builds Share build caches Extendable frontends to run Dockerfiles, or your publish your own Getting started \u00b6 On the left side is a table of contents, organized into sections that can be expanded to show topics they cover. Both the sections and topics are ordered from basic to advanced concepts. The guides are intended to contain practical explanations of how to write hlb builds, focusing on the most widely used features of hlb . For comprehensive documentation of every available instruction and option, see the Reference and Specification . The guides begin with a quick start to ensure your environment is working correctly, followed by a tutorial on how to write your first hlb program.","title":"What is HLB?"},{"location":"#key-features","text":"Efficient, expressive, and repeatable builds Share build caches Extendable frontends to run Dockerfiles, or your publish your own","title":"Key features"},{"location":"#getting-started","text":"On the left side is a table of contents, organized into sections that can be expanded to show topics they cover. Both the sections and topics are ordered from basic to advanced concepts. The guides are intended to contain practical explanations of how to write hlb builds, focusing on the most widely used features of hlb . For comprehensive documentation of every available instruction and option, see the Reference and Specification . The guides begin with a quick start to ensure your environment is working correctly, followed by a tutorial on how to write your first hlb program.","title":"Getting started"},{"location":"reference/","text":"Functions \u00b6 fs generate( fs frontend ) \u00b6 fs frontend a filesystem with an executable that runs a BuildKit gateway GRPC client over stdio. Generates a filesystem using an external frontend. 1 2 3 4 5 6 fs default () { generate fs { scratch; } with option { frontendInput \"key\" fs { scratch; } frontendOpt \"key\" \"value\" } } option::generate frontendInput( string key , fs value ) \u00b6 string key an unique key for the input. fs value a filesystem as an input. Provide an input filesystem to the external frontend. Read the documentation for the frontend to see what it will accept. option::generate frontendOpt( string key , string value ) \u00b6 string key an unique key for the option. string value a value for the option. Provide a key value pair to the external frontend. Read the documentation for the frontend to see what it will accept. fs git( string remote , string ref ) \u00b6 string remote the fully qualified git remote. string ref the git reference to check out. A filesystem with the files from a git repository checked out from a git reference. Note that by default, the `.git` directory is not included. 1 2 3 4 5 fs default () { git \"remote\" \"ref\" with option { keepGitDir } } option::git keepGitDir() \u00b6 Keeps the `.git` directory of the git repository. fs http( string url ) \u00b6 string url a fully-qualified URL to send a HTTP GET request. A filesystem with a file retrieved from a HTTP URL. 1 2 3 4 5 6 7 fs default () { http \"url\" with option { checksum \"digest\" chmod 0644 filename \"name\" } } option::http checksum( string digest ) \u00b6 string digest a checksum in the form of an OCI digest. https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests Verifies the checksum of the retrieved file against a digest. option::http chmod( octal filemode ) \u00b6 octal filemode the new permissions of the file in octal. Modifies the permissions of the retrieved file. option::http filename( string name ) \u00b6 string name the name of the file. Writes the retrieved file with a specified name. fs image( string ref ) \u00b6 string ref a docker registry reference. if not fully qualified, it will be expanded the same as the docker CLI. An OCI image's filesystem. 1 2 3 4 5 fs default () { image \"ref\" with option { resolve } } option::image resolve() \u00b6 Resolves the OCI Image Config and inherit its environment, working directory, and entrypoint. fs local( string path ) \u00b6 string path the local path to the directory to sync up. A filesystem with the files synced up from a directory on the local system. 1 2 3 4 5 6 7 fs default () { local \"path\" with option { excludePatterns \"pattern\" followPaths \"path\" includePatterns \"pattern\" } } option::local excludePatterns( string pattern ) \u00b6 string pattern a list of patterns for files that should not be synced. Sync only files that do not match any of the excluded patterns. option::local followPaths( string path ) \u00b6 string path a list of paths to files that may be symlinks. Sync the targets of symlinks if path is to a symlink. option::local includePatterns( string pattern ) \u00b6 string pattern a list of patterns for files that should be synced. Sync only files that match any of the included patterns. fs scratch() \u00b6 An empty filesystem. 1 2 3 fs default () { scratch } Methods \u00b6 fs ( fs ) copy( fs input , string src , string dst ) \u00b6 fs input the filesystem to copy from. string src the path from the input filesystem. string dst the path in the current filesystem. Copies a file from an input filesystem into the current filesystem. 1 2 3 4 5 6 7 8 9 fs default () { scratch copy fs { scratch; } \"src\" \"dst\" with option { contentsOnly createDestPath followSymlinks unpack } } option::copy contentsOnly() \u00b6 If the `src` path is a directory, only the contents of the directory is copied to the destination. option::copy createDestPath() \u00b6 Create the parent directories of the destination if they don't already exist. option::copy followSymlinks() \u00b6 Follow symlinks in the input filesystem and copy the symlink targets too. option::copy unpack() \u00b6 If the `src` path is an archive, attempt to unpack its contents into the destination. fs ( fs ) dir( string path ) \u00b6 string path the new working directory. Sets the working directory for all subsequent calls in this filesystem block. 1 2 3 4 fs default () { scratch dir \"path\" } fs ( fs ) env( string key , string value ) \u00b6 string key the environment key. string value the environment value. Sets an environment key pair for all subsequent calls in this filesystem block. 1 2 3 4 fs default () { scratch env \"key\" \"value\" } fs ( fs ) mkdir( string path , octal filemode ) \u00b6 string path the path of the directory. octal filemode the permissions of the directory. Creates a directory in the current filesystem. 1 2 3 4 5 6 7 8 fs default () { scratch mkdir \"path\" 0644 with option { chown \"owner\" createParents createdTime \"created\" } } option::mkdir chown( string owner ) \u00b6 string owner the user:group owner of the directory. Change the owner of the directory. option::mkdir createParents() \u00b6 Create the parent directories if they don't exist already. option::mkdir createdTime( string created ) \u00b6 string created the created time in the RFC3339 format. Sets the created time of the directory. fs ( fs ) mkfile( string path , octal filemode , string content ) \u00b6 string path the path of the file. octal filemode the permissions of the file. string content the contents of the file. Creates a file in the current filesystem. 1 2 3 4 5 6 7 fs default () { scratch mkfile \"path\" 0644 \"content\" with option { chown \"owner\" createdTime \"created\" } } option::mkfile chown( string owner ) \u00b6 string owner the user:group owner of the file. Change the owner of the file. option::mkfile createdTime( string created ) \u00b6 string created the created time in the RFC3339 format. Sets the created time of the file. fs ( fs ) rm( string path ) \u00b6 string path the path of the file to remove. Removes a file from the current filesystem. 1 2 3 4 5 6 7 fs default () { scratch rm \"path\" with option { allowNotFound allowWildcards } } option::rm allowNotFound() \u00b6 Allows the file to not be found. option::rm allowWildcards() \u00b6 Allows wildcards in the path to remove. fs ( fs ) run( string arg ) \u00b6 string arg a command to execute. Executes an command in the current filesystem. If no arguments are given, it will execute the current args set on the filesystem. If exactly one arg is given, it will attempt to parse as a command with shell-style quoting. If it remains a single element, it is executed directly, otherwise it is run with the current shell. If more than one arg is given, it will be executed directly, without a shell. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fs default () { scratch run \"arg\" with option { dir \"path\" env \"key\" \"value\" host \"hostname\" \"address\" mount fs { scratch; } \"mountPoint\" with option { readonly tmpfs sourcePath \"path\" cache \"cacheid\" \"sharingmode\" } network \"networkmode\" readonlyRootfs secret \"localPath\" \"mountPoint\" with option { uid 0 gid 0 mode 0644 } security \"securitymode\" ssh with option { target \"mountPoint\" localPath \"path\" uid 0 gid 0 mode 0644 } user \"name\" } } option::run dir( string path ) \u00b6 string path the new working directory. Sets the working directory for the duration of the run command. option::run env( string key , string value ) \u00b6 string key the environment key. string value the environment value. Sets an environment key pair for the duration of the run command. option::run host( string hostname , string address ) \u00b6 string hostname the host name of the entry, may include spaces to delimit multiple host names. string address the IP of the entry. Adds a host entry to /etc/hosts for the duration of the run command. option::run mount( fs input , string mountPoint ) \u00b6 fs input the additional filesystem to mount. the input's root filesystem becomes available from the mountPoint directory. string mountPoint the directory where the mount is attached. Attaches an additional filesystem for the duration of the run command. option::mount readonly() \u00b6 Sets the mount to be attached as a read-only filesystem. option::mount tmpfs() \u00b6 Sets the mount to be attached as a tmpfs filesystem. option::mount sourcePath( string path ) \u00b6 string path the path in the input filesystem. Mount a path from the input filesystem. By default, the root of the input filesystem is mounted. option::mount cache( string cacheid , string sharingmode ) \u00b6 string cacheid the unique ID to identify the cache. string sharingmode the sharing mode of the cache, must be one of the following: - shared: can be used concurrently by multiple writers. - private: creates a new mount if there are multiple writers. - locked: pauses additional writers until the first one releases the mount. Cache a snapshot of the mount after the run command has executed. A cacheid must be provided to uniquely identify the cache mount. Compilers and package managers commonly have an option to specify cache directories. Depending on their implementation, it may be safe to share the cache with concurrent processes. This is adjusted via the `sharingmode` argument. The cache is modified every time the parent run command is executed. A cache could also be managed by not using the `cache` option. Instead, the mount can be aliased, and then pushed as an image, so that there it can be a stable snapshot, or updated externally. option::run network( string networkmode ) \u00b6 string networkmode the network mode of the container, must be one of the following: - unset: use the default network provider. - host: use the host's network namespace. - none: disable networking. Sets the networking mode for the duration of the run command. By default, the value is \"unset\" (using BuildKit's CNI provider, otherwise its host namespace). option::run readonlyRootfs() \u00b6 Sets the rootfs as read-only for the duration of the run command. option::run secret( string localPath , string mountPoint ) \u00b6 string localPath the filepath for a secure file or directory. string mountPoint the directory where the secret is attached. Mounts a secure file for the duration of the run command. Secrets are attached via a tmpfs mount, so all the data stays in volatile memory. option::secret uid( int id ) \u00b6 int id the user id. Sets the user ID for the secure file. By default, the UID is 0. option::secret gid( int id ) \u00b6 int id the group id. Sets the group ID for the secure file. By default, the GID is 0. option::secret mode( octal filemode ) \u00b6 octal filemode the new permissions of the secure file in octal. Sets the permissions for the secure file. By default, the file mode is 0600. option::run security( string securitymode ) \u00b6 string securitymode the security mode of the container, must be one of the following: - sandbox: use the default containerd seccomp profile. - insecure: enables all capabilities. Sets the security mode for the duration of the run command. By default, the value is \"sandbox\". option::run ssh() \u00b6 Mounts a SSH socket for the duration of the run command. By default, it will try to use the SSH socket found from $SSH_AUTH_SOCK. Otherwise, an option `localPath` can be provided to specify a filepath to a SSH auth socket or *.pem file. option::ssh target( string mountPoint ) \u00b6 string mountPoint the directory where the SSH agent socket is attached. Sets the target directory to mount the SSH agent socket. By default, it is mounted to `/run/buildkit/ssh_agent.${N}`, where N is the index of the SSH socket. If $SSH_AUTH_SOCK is not set, it will set SSH_AUTH_SOCK to the mountPoint. option::ssh localPath( string path ) \u00b6 string path the path to a local SSH agent socket or PEM key. Sets the path to a local SSH agent socket or PEM key, with support for passphrases. By default, the SSH agent defined by $SSH_AUTH_SOCK will be mounted into the container. option::ssh uid( int id ) \u00b6 int id the user ID. Sets the user ID for the SSH agent socket. By default, the UID is 0. option::ssh gid( int id ) \u00b6 int id the group ID. Sets the group ID for the SSH agent socket. By default, the GID is 0. option::ssh mode( octal filemode ) \u00b6 octal filemode the new permissions of the SSH agent socket in octal. Sets the permissions for the SSH agent socket. By default, the file mode is 0600. option::run user( string name ) \u00b6 string name the name of the user. Sets the current user for the duration of the run command. fs ( fs ) shell( string arg ) \u00b6 string arg the list of args used to prefix `run` statements. Sets the current shell command to use when executing subsequent `run` methods. By default, this is [\"sh\", \"-c\"]. 1 2 3 4 fs default () { scratch shell \"arg\" } fs ( fs ) user( string name ) \u00b6 string name the name of the user. Sets the current user for all subsequent calls in this filesystem block. 1 2 3 4 fs default () { scratch user \"name\" } .hlb-type { color: #d73a49 } .hlb-variable { color: #0366d6 }","title":"Reference"},{"location":"reference/#functions","text":"","title":"Functions"},{"location":"reference/#fs-generatefs-frontend","text":"fs frontend a filesystem with an executable that runs a BuildKit gateway GRPC client over stdio. Generates a filesystem using an external frontend. 1 2 3 4 5 6 fs default () { generate fs { scratch; } with option { frontendInput \"key\" fs { scratch; } frontendOpt \"key\" \"value\" } }","title":"fs generate(fs frontend)"},{"location":"reference/#optiongenerate-frontendinputstring-key-fs-value","text":"string key an unique key for the input. fs value a filesystem as an input. Provide an input filesystem to the external frontend. Read the documentation for the frontend to see what it will accept.","title":"option::generate frontendInput(string key, fs value)"},{"location":"reference/#optiongenerate-frontendoptstring-key-string-value","text":"string key an unique key for the option. string value a value for the option. Provide a key value pair to the external frontend. Read the documentation for the frontend to see what it will accept.","title":"option::generate frontendOpt(string key, string value)"},{"location":"reference/#fs-gitstring-remote-string-ref","text":"string remote the fully qualified git remote. string ref the git reference to check out. A filesystem with the files from a git repository checked out from a git reference. Note that by default, the `.git` directory is not included. 1 2 3 4 5 fs default () { git \"remote\" \"ref\" with option { keepGitDir } }","title":"fs git(string remote, string ref)"},{"location":"reference/#optiongit-keepgitdir","text":"Keeps the `.git` directory of the git repository.","title":"option::git keepGitDir()"},{"location":"reference/#fs-httpstring-url","text":"string url a fully-qualified URL to send a HTTP GET request. A filesystem with a file retrieved from a HTTP URL. 1 2 3 4 5 6 7 fs default () { http \"url\" with option { checksum \"digest\" chmod 0644 filename \"name\" } }","title":"fs http(string url)"},{"location":"reference/#optionhttp-checksumstring-digest","text":"string digest a checksum in the form of an OCI digest. https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests Verifies the checksum of the retrieved file against a digest.","title":"option::http checksum(string digest)"},{"location":"reference/#optionhttp-chmodoctal-filemode","text":"octal filemode the new permissions of the file in octal. Modifies the permissions of the retrieved file.","title":"option::http chmod(octal filemode)"},{"location":"reference/#optionhttp-filenamestring-name","text":"string name the name of the file. Writes the retrieved file with a specified name.","title":"option::http filename(string name)"},{"location":"reference/#fs-imagestring-ref","text":"string ref a docker registry reference. if not fully qualified, it will be expanded the same as the docker CLI. An OCI image's filesystem. 1 2 3 4 5 fs default () { image \"ref\" with option { resolve } }","title":"fs image(string ref)"},{"location":"reference/#optionimage-resolve","text":"Resolves the OCI Image Config and inherit its environment, working directory, and entrypoint.","title":"option::image resolve()"},{"location":"reference/#fs-localstring-path","text":"string path the local path to the directory to sync up. A filesystem with the files synced up from a directory on the local system. 1 2 3 4 5 6 7 fs default () { local \"path\" with option { excludePatterns \"pattern\" followPaths \"path\" includePatterns \"pattern\" } }","title":"fs local(string path)"},{"location":"reference/#optionlocal-excludepatternsstring-pattern","text":"string pattern a list of patterns for files that should not be synced. Sync only files that do not match any of the excluded patterns.","title":"option::local excludePatterns(string pattern)"},{"location":"reference/#optionlocal-followpathsstring-path","text":"string path a list of paths to files that may be symlinks. Sync the targets of symlinks if path is to a symlink.","title":"option::local followPaths(string path)"},{"location":"reference/#optionlocal-includepatternsstring-pattern","text":"string pattern a list of patterns for files that should be synced. Sync only files that match any of the included patterns.","title":"option::local includePatterns(string pattern)"},{"location":"reference/#fs-scratch","text":"An empty filesystem. 1 2 3 fs default () { scratch }","title":"fs scratch()"},{"location":"reference/#methods","text":"","title":"Methods"},{"location":"reference/#fs-fs-copyfs-input-string-src-string-dst","text":"fs input the filesystem to copy from. string src the path from the input filesystem. string dst the path in the current filesystem. Copies a file from an input filesystem into the current filesystem. 1 2 3 4 5 6 7 8 9 fs default () { scratch copy fs { scratch; } \"src\" \"dst\" with option { contentsOnly createDestPath followSymlinks unpack } }","title":"fs (fs) copy(fs input, string src, string dst)"},{"location":"reference/#optioncopy-contentsonly","text":"If the `src` path is a directory, only the contents of the directory is copied to the destination.","title":"option::copy contentsOnly()"},{"location":"reference/#optioncopy-createdestpath","text":"Create the parent directories of the destination if they don't already exist.","title":"option::copy createDestPath()"},{"location":"reference/#optioncopy-followsymlinks","text":"Follow symlinks in the input filesystem and copy the symlink targets too.","title":"option::copy followSymlinks()"},{"location":"reference/#optioncopy-unpack","text":"If the `src` path is an archive, attempt to unpack its contents into the destination.","title":"option::copy unpack()"},{"location":"reference/#fs-fs-dirstring-path","text":"string path the new working directory. Sets the working directory for all subsequent calls in this filesystem block. 1 2 3 4 fs default () { scratch dir \"path\" }","title":"fs (fs) dir(string path)"},{"location":"reference/#fs-fs-envstring-key-string-value","text":"string key the environment key. string value the environment value. Sets an environment key pair for all subsequent calls in this filesystem block. 1 2 3 4 fs default () { scratch env \"key\" \"value\" }","title":"fs (fs) env(string key, string value)"},{"location":"reference/#fs-fs-mkdirstring-path-octal-filemode","text":"string path the path of the directory. octal filemode the permissions of the directory. Creates a directory in the current filesystem. 1 2 3 4 5 6 7 8 fs default () { scratch mkdir \"path\" 0644 with option { chown \"owner\" createParents createdTime \"created\" } }","title":"fs (fs) mkdir(string path, octal filemode)"},{"location":"reference/#optionmkdir-chownstring-owner","text":"string owner the user:group owner of the directory. Change the owner of the directory.","title":"option::mkdir chown(string owner)"},{"location":"reference/#optionmkdir-createparents","text":"Create the parent directories if they don't exist already.","title":"option::mkdir createParents()"},{"location":"reference/#optionmkdir-createdtimestring-created","text":"string created the created time in the RFC3339 format. Sets the created time of the directory.","title":"option::mkdir createdTime(string created)"},{"location":"reference/#fs-fs-mkfilestring-path-octal-filemode-string-content","text":"string path the path of the file. octal filemode the permissions of the file. string content the contents of the file. Creates a file in the current filesystem. 1 2 3 4 5 6 7 fs default () { scratch mkfile \"path\" 0644 \"content\" with option { chown \"owner\" createdTime \"created\" } }","title":"fs (fs) mkfile(string path, octal filemode, string content)"},{"location":"reference/#optionmkfile-chownstring-owner","text":"string owner the user:group owner of the file. Change the owner of the file.","title":"option::mkfile chown(string owner)"},{"location":"reference/#optionmkfile-createdtimestring-created","text":"string created the created time in the RFC3339 format. Sets the created time of the file.","title":"option::mkfile createdTime(string created)"},{"location":"reference/#fs-fs-rmstring-path","text":"string path the path of the file to remove. Removes a file from the current filesystem. 1 2 3 4 5 6 7 fs default () { scratch rm \"path\" with option { allowNotFound allowWildcards } }","title":"fs (fs) rm(string path)"},{"location":"reference/#optionrm-allownotfound","text":"Allows the file to not be found.","title":"option::rm allowNotFound()"},{"location":"reference/#optionrm-allowwildcards","text":"Allows wildcards in the path to remove.","title":"option::rm allowWildcards()"},{"location":"reference/#fs-fs-runstring-arg","text":"string arg a command to execute. Executes an command in the current filesystem. If no arguments are given, it will execute the current args set on the filesystem. If exactly one arg is given, it will attempt to parse as a command with shell-style quoting. If it remains a single element, it is executed directly, otherwise it is run with the current shell. If more than one arg is given, it will be executed directly, without a shell. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fs default () { scratch run \"arg\" with option { dir \"path\" env \"key\" \"value\" host \"hostname\" \"address\" mount fs { scratch; } \"mountPoint\" with option { readonly tmpfs sourcePath \"path\" cache \"cacheid\" \"sharingmode\" } network \"networkmode\" readonlyRootfs secret \"localPath\" \"mountPoint\" with option { uid 0 gid 0 mode 0644 } security \"securitymode\" ssh with option { target \"mountPoint\" localPath \"path\" uid 0 gid 0 mode 0644 } user \"name\" } }","title":"fs (fs) run(string arg)"},{"location":"reference/#optionrun-dirstring-path","text":"string path the new working directory. Sets the working directory for the duration of the run command.","title":"option::run dir(string path)"},{"location":"reference/#optionrun-envstring-key-string-value","text":"string key the environment key. string value the environment value. Sets an environment key pair for the duration of the run command.","title":"option::run env(string key, string value)"},{"location":"reference/#optionrun-hoststring-hostname-string-address","text":"string hostname the host name of the entry, may include spaces to delimit multiple host names. string address the IP of the entry. Adds a host entry to /etc/hosts for the duration of the run command.","title":"option::run host(string hostname, string address)"},{"location":"reference/#optionrun-mountfs-input-string-mountpoint","text":"fs input the additional filesystem to mount. the input's root filesystem becomes available from the mountPoint directory. string mountPoint the directory where the mount is attached. Attaches an additional filesystem for the duration of the run command.","title":"option::run mount(fs input, string mountPoint)"},{"location":"reference/#optionmount-readonly","text":"Sets the mount to be attached as a read-only filesystem.","title":"option::mount readonly()"},{"location":"reference/#optionmount-tmpfs","text":"Sets the mount to be attached as a tmpfs filesystem.","title":"option::mount tmpfs()"},{"location":"reference/#optionmount-sourcepathstring-path","text":"string path the path in the input filesystem. Mount a path from the input filesystem. By default, the root of the input filesystem is mounted.","title":"option::mount sourcePath(string path)"},{"location":"reference/#optionmount-cachestring-cacheid-string-sharingmode","text":"string cacheid the unique ID to identify the cache. string sharingmode the sharing mode of the cache, must be one of the following: - shared: can be used concurrently by multiple writers. - private: creates a new mount if there are multiple writers. - locked: pauses additional writers until the first one releases the mount. Cache a snapshot of the mount after the run command has executed. A cacheid must be provided to uniquely identify the cache mount. Compilers and package managers commonly have an option to specify cache directories. Depending on their implementation, it may be safe to share the cache with concurrent processes. This is adjusted via the `sharingmode` argument. The cache is modified every time the parent run command is executed. A cache could also be managed by not using the `cache` option. Instead, the mount can be aliased, and then pushed as an image, so that there it can be a stable snapshot, or updated externally.","title":"option::mount cache(string cacheid, string sharingmode)"},{"location":"reference/#optionrun-networkstring-networkmode","text":"string networkmode the network mode of the container, must be one of the following: - unset: use the default network provider. - host: use the host's network namespace. - none: disable networking. Sets the networking mode for the duration of the run command. By default, the value is \"unset\" (using BuildKit's CNI provider, otherwise its host namespace).","title":"option::run network(string networkmode)"},{"location":"reference/#optionrun-readonlyrootfs","text":"Sets the rootfs as read-only for the duration of the run command.","title":"option::run readonlyRootfs()"},{"location":"reference/#optionrun-secretstring-localpath-string-mountpoint","text":"string localPath the filepath for a secure file or directory. string mountPoint the directory where the secret is attached. Mounts a secure file for the duration of the run command. Secrets are attached via a tmpfs mount, so all the data stays in volatile memory.","title":"option::run secret(string localPath, string mountPoint)"},{"location":"reference/#optionsecret-uidint-id","text":"int id the user id. Sets the user ID for the secure file. By default, the UID is 0.","title":"option::secret uid(int id)"},{"location":"reference/#optionsecret-gidint-id","text":"int id the group id. Sets the group ID for the secure file. By default, the GID is 0.","title":"option::secret gid(int id)"},{"location":"reference/#optionsecret-modeoctal-filemode","text":"octal filemode the new permissions of the secure file in octal. Sets the permissions for the secure file. By default, the file mode is 0600.","title":"option::secret mode(octal filemode)"},{"location":"reference/#optionrun-securitystring-securitymode","text":"string securitymode the security mode of the container, must be one of the following: - sandbox: use the default containerd seccomp profile. - insecure: enables all capabilities. Sets the security mode for the duration of the run command. By default, the value is \"sandbox\".","title":"option::run security(string securitymode)"},{"location":"reference/#optionrun-ssh","text":"Mounts a SSH socket for the duration of the run command. By default, it will try to use the SSH socket found from $SSH_AUTH_SOCK. Otherwise, an option `localPath` can be provided to specify a filepath to a SSH auth socket or *.pem file.","title":"option::run ssh()"},{"location":"reference/#optionssh-targetstring-mountpoint","text":"string mountPoint the directory where the SSH agent socket is attached. Sets the target directory to mount the SSH agent socket. By default, it is mounted to `/run/buildkit/ssh_agent.${N}`, where N is the index of the SSH socket. If $SSH_AUTH_SOCK is not set, it will set SSH_AUTH_SOCK to the mountPoint.","title":"option::ssh target(string mountPoint)"},{"location":"reference/#optionssh-localpathstring-path","text":"string path the path to a local SSH agent socket or PEM key. Sets the path to a local SSH agent socket or PEM key, with support for passphrases. By default, the SSH agent defined by $SSH_AUTH_SOCK will be mounted into the container.","title":"option::ssh localPath(string path)"},{"location":"reference/#optionssh-uidint-id","text":"int id the user ID. Sets the user ID for the SSH agent socket. By default, the UID is 0.","title":"option::ssh uid(int id)"},{"location":"reference/#optionssh-gidint-id","text":"int id the group ID. Sets the group ID for the SSH agent socket. By default, the GID is 0.","title":"option::ssh gid(int id)"},{"location":"reference/#optionssh-modeoctal-filemode","text":"octal filemode the new permissions of the SSH agent socket in octal. Sets the permissions for the SSH agent socket. By default, the file mode is 0600.","title":"option::ssh mode(octal filemode)"},{"location":"reference/#optionrun-userstring-name","text":"string name the name of the user. Sets the current user for the duration of the run command.","title":"option::run user(string name)"},{"location":"reference/#fs-fs-shellstring-arg","text":"string arg the list of args used to prefix `run` statements. Sets the current shell command to use when executing subsequent `run` methods. By default, this is [\"sh\", \"-c\"]. 1 2 3 4 fs default () { scratch shell \"arg\" }","title":"fs (fs) shell(string arg)"},{"location":"reference/#fs-fs-userstring-name","text":"string name the name of the user. Sets the current user for all subsequent calls in this filesystem block. 1 2 3 4 fs default () { scratch user \"name\" } .hlb-type { color: #d73a49 } .hlb-variable { color: #0366d6 }","title":"fs (fs) user(string name)"},{"location":"specification/","text":"This is the draft specification for the High Level Build (HLB) programming language. HLB is a functional language to describe a build and its dependencies. It is strongly typed, and implicitly constructs a build graph that is evaluated efficiently and concurrently. Programs are defined in a .hlb file, and may consume build graphs produced by other systems (Dockerfiles, Buildpacks, etc). The grammar is compact and regular, allowing for SDKs to be implemented for common programming languages to emit HLB. Notation \u00b6 The syntax is specified using Extended Backus-Naur Form (EBNF). Source code representation \u00b6 Characters \u00b6 newline = /* the Unicode code point U +000 A */ . unicode_char = /* an arbitrary Unicode code point except newline */ . Letters and digits \u00b6 decimal_digit = \"0\" \u2026 \"9\" . octal_digit = \"0\" \u2026 \"7\" . Lexical elements \u00b6 String literals \u00b6 string_lit = quoted_string_lit | double_quoted_string_lit quoted_string_lit = ` '` { unicode_char } `' ` double_quoted_string_lit = ` \"` { unicode_char } `\" ` Octal literals \u00b6 octal_lit = octal_digits . octal_digits = octal_digit { octal_digit } . Integer literals \u00b6 int_lit = \"0\" | ( \"1\" \u2026 \"9\" ) [ decimal_digits ] . decimal_digits = decimal_digit { decimal_digit } . Bool literals \u00b6 bool_lit = \"true\" | \"false\" . Types \u00b6 Function types \u00b6 ReturnType = Type . Parameters = \"(\" [ ParameterList [ \",\" ] ] \")\" . ParameterList = ParameterDecl { \",\" ParameterDecl } . ParameterDecl = [ Variadic ] Type ParameterName . ParameterName = identifier . Variadic = \"variadic\" . Declarations \u00b6 Declaration = FunctionDecl . Function declarations \u00b6 FunctionDecl = ReturnType ( ) FunctionName Parameters [ FunctionBody ] . FunctionName = identifier . FunctionBody = Block . Alias declarations \u00b6 AliasDecl = \"as\" FunctionName . Expressions \u00b6 ExprList = Expr { Expr } . Expr = identifier | BasicLit | FuncLit . Operands \u00b6 BasicLit = string_lit | octal_lit | int_lit | bool_lit . FuncLit = ReturnType Block . Statements \u00b6 Block = \"{\" StatementList \"}\" . StatementList = { Statement \";\" } . Statement = CallStatement Call statements \u00b6 CallStatement = FunctionName [ ExprList ] [ WithOption ] [ AliasDecl ] . WithOption = \"with\" Option Option = identifier | FuncLit .","title":"Specification"},{"location":"specification/#notation","text":"The syntax is specified using Extended Backus-Naur Form (EBNF).","title":"Notation"},{"location":"specification/#source-code-representation","text":"","title":"Source code representation"},{"location":"specification/#characters","text":"newline = /* the Unicode code point U +000 A */ . unicode_char = /* an arbitrary Unicode code point except newline */ .","title":"Characters"},{"location":"specification/#letters-and-digits","text":"decimal_digit = \"0\" \u2026 \"9\" . octal_digit = \"0\" \u2026 \"7\" .","title":"Letters and digits"},{"location":"specification/#lexical-elements","text":"","title":"Lexical elements"},{"location":"specification/#string-literals","text":"string_lit = quoted_string_lit | double_quoted_string_lit quoted_string_lit = ` '` { unicode_char } `' ` double_quoted_string_lit = ` \"` { unicode_char } `\" `","title":"String literals"},{"location":"specification/#octal-literals","text":"octal_lit = octal_digits . octal_digits = octal_digit { octal_digit } .","title":"Octal literals"},{"location":"specification/#integer-literals","text":"int_lit = \"0\" | ( \"1\" \u2026 \"9\" ) [ decimal_digits ] . decimal_digits = decimal_digit { decimal_digit } .","title":"Integer literals"},{"location":"specification/#bool-literals","text":"bool_lit = \"true\" | \"false\" .","title":"Bool literals"},{"location":"specification/#types","text":"","title":"Types"},{"location":"specification/#function-types","text":"ReturnType = Type . Parameters = \"(\" [ ParameterList [ \",\" ] ] \")\" . ParameterList = ParameterDecl { \",\" ParameterDecl } . ParameterDecl = [ Variadic ] Type ParameterName . ParameterName = identifier . Variadic = \"variadic\" .","title":"Function types"},{"location":"specification/#declarations","text":"Declaration = FunctionDecl .","title":"Declarations"},{"location":"specification/#function-declarations","text":"FunctionDecl = ReturnType ( ) FunctionName Parameters [ FunctionBody ] . FunctionName = identifier . FunctionBody = Block .","title":"Function declarations"},{"location":"specification/#alias-declarations","text":"AliasDecl = \"as\" FunctionName .","title":"Alias declarations"},{"location":"specification/#expressions","text":"ExprList = Expr { Expr } . Expr = identifier | BasicLit | FuncLit .","title":"Expressions"},{"location":"specification/#operands","text":"BasicLit = string_lit | octal_lit | int_lit | bool_lit . FuncLit = ReturnType Block .","title":"Operands"},{"location":"specification/#statements","text":"Block = \"{\" StatementList \"}\" . StatementList = { Statement \";\" } . Statement = CallStatement","title":"Statements"},{"location":"specification/#call-statements","text":"CallStatement = FunctionName [ ExprList ] [ WithOption ] [ AliasDecl ] . WithOption = \"with\" Option Option = identifier | FuncLit .","title":"Call statements"},{"location":"intro/quickstart/","text":"This guide will teach you how to setup hlb and run a build to output hello world . Installation \u00b6 If you're on a MacOS or Linux ( linux-amd64 ), head on over to Releases to grab a static binary. Otherwise, you can compile HLB yourself using go : go get -u github.com/openllb/hlb/cmd/hlb You'll also need to run buildkitd somewhere you can connect to. The easiest way if you have Docker , is to run a local buildkit container: # We're still waiting on some upstream PRs to be merged, but soon you'll be able to use standard moby/buildkit docker run -d --name buildkitd --privileged openllb/buildkit:experimental Run your first build \u00b6 Now that you have installed hlb , we can run our first build. Typically, we will write our program in a file with a .hlb extension, but for our first build we can just pipe the program in from stdin. Try it yourself! export BUILDKIT_HOST = docker-container://buildkitd echo 'fs default() { scratch; mkfile \"/out\" 0o644 \"hello world\"; }' | hlb run --download . Once the build has finished, you should end up with a file output in your working directory. $ cat output hello world Congratulations! You've now ran your first hlb build and downloaded the output back to your system. Tip By default, once the build has finished, nothing is exported anywhere. You'll need to specify where the results go, e.g. to your host as a tarball, or pushed to a Docker registry. Now that we've verified hlb is functioning, it's time to start the tutorial .","title":"Quickstart"},{"location":"intro/quickstart/#installation","text":"If you're on a MacOS or Linux ( linux-amd64 ), head on over to Releases to grab a static binary. Otherwise, you can compile HLB yourself using go : go get -u github.com/openllb/hlb/cmd/hlb You'll also need to run buildkitd somewhere you can connect to. The easiest way if you have Docker , is to run a local buildkit container: # We're still waiting on some upstream PRs to be merged, but soon you'll be able to use standard moby/buildkit docker run -d --name buildkitd --privileged openllb/buildkit:experimental","title":"Installation"},{"location":"intro/quickstart/#run-your-first-build","text":"Now that you have installed hlb , we can run our first build. Typically, we will write our program in a file with a .hlb extension, but for our first build we can just pipe the program in from stdin. Try it yourself! export BUILDKIT_HOST = docker-container://buildkitd echo 'fs default() { scratch; mkfile \"/out\" 0o644 \"hello world\"; }' | hlb run --download . Once the build has finished, you should end up with a file output in your working directory. $ cat output hello world Congratulations! You've now ran your first hlb build and downloaded the output back to your system. Tip By default, once the build has finished, nothing is exported anywhere. You'll need to specify where the results go, e.g. to your host as a tarball, or pushed to a Docker registry. Now that we've verified hlb is functioning, it's time to start the tutorial .","title":"Run your first build"},{"location":"tutorial/arguments/","text":"At the end of the previous chapter, we were left with this: 1 2 3 4 5 6 7 8 9 10 11 12 fs src () { git \"https://github.com/left-pad/left-pad.git\" \"master\" } fs npmInstall () { image \"node:alpine\" dir \"/src\" run \"npm install\" with option { mount src \"/src\" mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Currently our git repository is hardcoded into our program. Let's refactor it out so we can build nodeModules for other node projects. Refactoring our program \u00b6 When considering what to change to variables, we want to aim for extensibility. One approach may be to change the git remote into a variable, but that would mean we're stuck with git sources. Instead, let's refactor src to npmInstall 's function arguments so that we are opaque to where the source comes from. 1 2 3 4 5 6 7 8 fs npmInstall ( fs src ) { image \"node:alpine\" dir \"/src\" run \"npm install\" with option { mount src \"/src\" mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Great! Now we can write a new function named remoteModules to pass in our git source. However, we don't want to invoke npmInstall because that will return the alpine filesystem, what we rather want is nodeModules . When an alias is declared in the body of a fs block, it also inherits the signature of the parent function. This is because nodeModules depends on the value of src , so when we defined a signature for npmInstall , nodeModules also inherited the signature: 1 fs nodeModules ( fs src ) We know how to invoke nodeModules , so let's pass the same git source we used earlier. 1 2 3 fs remoteModules () { nodeModules fs { git \"https://github.com/left-pad/left-pad.git\" \"master\" ; } } There we have it. A reusable nodeModules function that is opaque to where the source code comes from. Let's take a look at one more type of source filesystem. Local sources \u00b6 So far we have been dealing with only remote sources like image and git , but what if you wanted to provide your working directory as a source filesystem? Turns out there is a source local that provides just that ability. Here's the signature: 1 2 # Rsyncs a local directory at path to a scratch filesystem. fs local ( string path ) We don't have a local node project at the moment, so let's write a function to initialize a node project and add left-pad as a dependency. We learnt how to use arguments just now, so let's apply our learnings and write a generic function. 1 2 3 4 5 6 7 8 9 10 11 12 13 fs npmInit ( string package ) { image \"node:alpine\" dir \"/src\" run string { format \"npm init -y && npm install --package-lock-only %s\" package } with option { mount fs { scratch; } \"/src\" as nodeProject } } fs nodeProjectWithLeftPad () { nodeProject \"left-pad\" } This time, instead of passing a string literal, we can pass a string block literal where we have access to string functions like format . This allows us to interpolate values into string to install an arbitrary package. When you're ready, run a build targetting nodeProjectWithLeftPad and download the initialized node project. hlb run --target nodeProjectWithLeftPad --download . node.hlb You should see two new files package.json and package-lock.json in your working directory. $ ls node.hlb package.json package-lock.json Now we can use the local source to download node_modules , but let's also use a includePatterns option to specify exactly what files we should sync up. 1 2 3 4 5 6 7 fs localModules () { nodeModules fs { local \".\" with option { includePatterns \"package.json\" \"package-lock.json\" } } } And finally, we can run npm install remotely using our working directory and transfer back the node_modules . hlb run --target localModules --download node_modules node.hlb Advanced concepts \u00b6 You've made it to the end of basic concepts! Throughout the last few chapters, you wrote a few hlb programs to run npm install downloaded just the node_modules directory back to your system. You refactored it so that the function can be opaque to what the source comes from, and then you provided your working directory as a source filesystem. Next up, you can start writing your own hlb programs with the help of the Reference . As your build graphs grow in complexity, it will be crucial to be able to introspect and diagonose issues as they come up. The next chapter will walk through the debugger that comes with the hlb CLI.","title":"Using arguments"},{"location":"tutorial/arguments/#refactoring-our-program","text":"When considering what to change to variables, we want to aim for extensibility. One approach may be to change the git remote into a variable, but that would mean we're stuck with git sources. Instead, let's refactor src to npmInstall 's function arguments so that we are opaque to where the source comes from. 1 2 3 4 5 6 7 8 fs npmInstall ( fs src ) { image \"node:alpine\" dir \"/src\" run \"npm install\" with option { mount src \"/src\" mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Great! Now we can write a new function named remoteModules to pass in our git source. However, we don't want to invoke npmInstall because that will return the alpine filesystem, what we rather want is nodeModules . When an alias is declared in the body of a fs block, it also inherits the signature of the parent function. This is because nodeModules depends on the value of src , so when we defined a signature for npmInstall , nodeModules also inherited the signature: 1 fs nodeModules ( fs src ) We know how to invoke nodeModules , so let's pass the same git source we used earlier. 1 2 3 fs remoteModules () { nodeModules fs { git \"https://github.com/left-pad/left-pad.git\" \"master\" ; } } There we have it. A reusable nodeModules function that is opaque to where the source code comes from. Let's take a look at one more type of source filesystem.","title":"Refactoring our program"},{"location":"tutorial/arguments/#local-sources","text":"So far we have been dealing with only remote sources like image and git , but what if you wanted to provide your working directory as a source filesystem? Turns out there is a source local that provides just that ability. Here's the signature: 1 2 # Rsyncs a local directory at path to a scratch filesystem. fs local ( string path ) We don't have a local node project at the moment, so let's write a function to initialize a node project and add left-pad as a dependency. We learnt how to use arguments just now, so let's apply our learnings and write a generic function. 1 2 3 4 5 6 7 8 9 10 11 12 13 fs npmInit ( string package ) { image \"node:alpine\" dir \"/src\" run string { format \"npm init -y && npm install --package-lock-only %s\" package } with option { mount fs { scratch; } \"/src\" as nodeProject } } fs nodeProjectWithLeftPad () { nodeProject \"left-pad\" } This time, instead of passing a string literal, we can pass a string block literal where we have access to string functions like format . This allows us to interpolate values into string to install an arbitrary package. When you're ready, run a build targetting nodeProjectWithLeftPad and download the initialized node project. hlb run --target nodeProjectWithLeftPad --download . node.hlb You should see two new files package.json and package-lock.json in your working directory. $ ls node.hlb package.json package-lock.json Now we can use the local source to download node_modules , but let's also use a includePatterns option to specify exactly what files we should sync up. 1 2 3 4 5 6 7 fs localModules () { nodeModules fs { local \".\" with option { includePatterns \"package.json\" \"package-lock.json\" } } } And finally, we can run npm install remotely using our working directory and transfer back the node_modules . hlb run --target localModules --download node_modules node.hlb","title":"Local sources"},{"location":"tutorial/arguments/#advanced-concepts","text":"You've made it to the end of basic concepts! Throughout the last few chapters, you wrote a few hlb programs to run npm install downloaded just the node_modules directory back to your system. You refactored it so that the function can be opaque to what the source comes from, and then you provided your working directory as a source filesystem. Next up, you can start writing your own hlb programs with the help of the Reference . As your build graphs grow in complexity, it will be crucial to be able to introspect and diagonose issues as they come up. The next chapter will walk through the debugger that comes with the hlb CLI.","title":"Advanced concepts"},{"location":"tutorial/improving/","text":"In the previous chapter, we wrote our first hlb program to install the dependencies of a node project. It currently looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" } fs nodeModules () { scratch copy npmInstall \"/src/node_modules\" \"/\" } If we change to a bigger project, copying over the node_modules to a scratch filesystem only to isolate the directory is pretty expensive. In this chapter, we'll learn about techniques to improve our build which isn't available through the Dockerfile frontend. Removing the unnecessary copy \u00b6 Instructions like image , run , and copy are also regular functions, and you must invoke them with the required arguments. But some builtin functions have optional features that can be accessed in an option block. For example, run has an optional function mount that temporarily mounts a filesystem to a mountpoint directory while run is executing. The builtin mount function has the following signature: 1 2 # Mounts a source filesystem to the specific mountpoint. fs mount ( fs source , string mountpoint ) We can apply options to the run function by adding with <option> after the arguments, where option can be a function or a block literal. Let's first take a look at block literals. 1 2 3 4 5 6 7 8 9 10 11 12 13 # A block literal that returns type `option`. option { mount foo \"/foo\" mount bar \"/bar\" } # An inline block literal that returns type `fs`. fs { scratch; } option { # Mount taking a `fs` block literal as the source filesystem. mount fs { scratch; } \"/output\" } Block literals cannot be defined in the global scope, but you can define them where an argument is expected. When the statements within a block are all in one line, each statement must be suffixed with a ; as a delimiter. In the final example above, we defined an option block literal that mounts a scratch filesystem into /output , ready to receive output files. Handy! Now with this new ability, let's avoid the unnecessary copy ! 1 2 3 4 5 6 7 8 9 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" with option { mount fs { scratch; } \"/src/node_modules\" } } This time, when npm install runs, it will write the files directly into the scratch filesystem we mounted to /src/node_modules . Hooray! But wait, if we run the build targeting npmInstall , that will still give us the alpine filesystem. Not only that, once npm install has finished, the scratch filesystem will be unmounted leaving behind no node_modules directory at all! Haven't we made things worse? Fear not, for there is still one last concept to introduce! Defining aliases \u00b6 Currently, the only targets we can run are functions we defined in the global scope. We can also target statements inside the body of a function by defining an alias. After the arguments to the function and the optional with <option> block, you can add as <identifier> to define an alias for the filesystem at that step. Usually options are not allowed to be aliased but mount is an exception. 1 2 3 4 5 6 7 8 9 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" with option { mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Try running a build targetting nodeModules now, and this time we don't have to download it. hlb run --target nodeModules node.hlb Your build should complete slightly quicker (or much quicker if you had more dependencies), but we don't have to stop there. We briefly mentioned in the previous chapter that we chose to start from a filesystem of a Docker image, so we can explore other source functions too. Git sources \u00b6 Before npm install happens, we need to clone the repository, and before that happens we need to download the node:alpine image. However, cloning the repository doesn't strictly depend on the node:alpine image. What if we could pull the image and clone the repository concurrently? Using the mount function we just learnt, we can define a new fs function that clones the repository and mount it. But that will still require another image. Luckily for us there is a git builtin function that can efficiently prepare a filesystem containing a git repository! Here's the signature: 1 2 3 # Creates a scratch filesystem with a git repostory from remote checked out at # a specified branch, commit or tag. fs git ( string remote , string ref ) Instead of cloning the repository and then running it, we can implicitly depend on a function that checkouts our repository. 1 2 3 4 5 6 7 8 9 10 11 12 fs src () { git \"https://github.com/left-pad/left-pad.git\" \"master\" } fs npmInstall () { image \"node:alpine\" dir \"/src\" run \"npm install\" with option { mount src \"/src\" mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Run the build again to see the speed improve once again. hlb run --target npmInstall node.hlb Formatting Consistency helps with readability, so hlb comes with a formatter so that programs will look consistently formatted. Simply run hlb format -w node.hlb and it will format your file for you. Recap \u00b6 At the end of two chapters, we have wrote our first hlb program and optimized it by writing node_modules into a mount. Then we improved it a little more by leveraging a git source, allowing the clone to happen concurrently with the pull of the node:alpine image. You may have noticed that all this time, all our functions we defined had no arguments. In the next chapter, we'll refactor our example to make our program more generic.","title":"Improving our program"},{"location":"tutorial/improving/#removing-the-unnecessary-copy","text":"Instructions like image , run , and copy are also regular functions, and you must invoke them with the required arguments. But some builtin functions have optional features that can be accessed in an option block. For example, run has an optional function mount that temporarily mounts a filesystem to a mountpoint directory while run is executing. The builtin mount function has the following signature: 1 2 # Mounts a source filesystem to the specific mountpoint. fs mount ( fs source , string mountpoint ) We can apply options to the run function by adding with <option> after the arguments, where option can be a function or a block literal. Let's first take a look at block literals. 1 2 3 4 5 6 7 8 9 10 11 12 13 # A block literal that returns type `option`. option { mount foo \"/foo\" mount bar \"/bar\" } # An inline block literal that returns type `fs`. fs { scratch; } option { # Mount taking a `fs` block literal as the source filesystem. mount fs { scratch; } \"/output\" } Block literals cannot be defined in the global scope, but you can define them where an argument is expected. When the statements within a block are all in one line, each statement must be suffixed with a ; as a delimiter. In the final example above, we defined an option block literal that mounts a scratch filesystem into /output , ready to receive output files. Handy! Now with this new ability, let's avoid the unnecessary copy ! 1 2 3 4 5 6 7 8 9 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" with option { mount fs { scratch; } \"/src/node_modules\" } } This time, when npm install runs, it will write the files directly into the scratch filesystem we mounted to /src/node_modules . Hooray! But wait, if we run the build targeting npmInstall , that will still give us the alpine filesystem. Not only that, once npm install has finished, the scratch filesystem will be unmounted leaving behind no node_modules directory at all! Haven't we made things worse? Fear not, for there is still one last concept to introduce!","title":"Removing the unnecessary copy"},{"location":"tutorial/improving/#defining-aliases","text":"Currently, the only targets we can run are functions we defined in the global scope. We can also target statements inside the body of a function by defining an alias. After the arguments to the function and the optional with <option> block, you can add as <identifier> to define an alias for the filesystem at that step. Usually options are not allowed to be aliased but mount is an exception. 1 2 3 4 5 6 7 8 9 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" with option { mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Try running a build targetting nodeModules now, and this time we don't have to download it. hlb run --target nodeModules node.hlb Your build should complete slightly quicker (or much quicker if you had more dependencies), but we don't have to stop there. We briefly mentioned in the previous chapter that we chose to start from a filesystem of a Docker image, so we can explore other source functions too.","title":"Defining aliases"},{"location":"tutorial/improving/#git-sources","text":"Before npm install happens, we need to clone the repository, and before that happens we need to download the node:alpine image. However, cloning the repository doesn't strictly depend on the node:alpine image. What if we could pull the image and clone the repository concurrently? Using the mount function we just learnt, we can define a new fs function that clones the repository and mount it. But that will still require another image. Luckily for us there is a git builtin function that can efficiently prepare a filesystem containing a git repository! Here's the signature: 1 2 3 # Creates a scratch filesystem with a git repostory from remote checked out at # a specified branch, commit or tag. fs git ( string remote , string ref ) Instead of cloning the repository and then running it, we can implicitly depend on a function that checkouts our repository. 1 2 3 4 5 6 7 8 9 10 11 12 fs src () { git \"https://github.com/left-pad/left-pad.git\" \"master\" } fs npmInstall () { image \"node:alpine\" dir \"/src\" run \"npm install\" with option { mount src \"/src\" mount fs { scratch; } \"/src/node_modules\" as nodeModules } } Run the build again to see the speed improve once again. hlb run --target npmInstall node.hlb Formatting Consistency helps with readability, so hlb comes with a formatter so that programs will look consistently formatted. Simply run hlb format -w node.hlb and it will format your file for you.","title":"Git sources"},{"location":"tutorial/improving/#recap","text":"At the end of two chapters, we have wrote our first hlb program and optimized it by writing node_modules into a mount. Then we improved it a little more by leveraging a git source, allowing the clone to happen concurrently with the pull of the node:alpine image. You may have noticed that all this time, all our functions we defined had no arguments. In the next chapter, we'll refactor our example to make our program more generic.","title":"Recap"},{"location":"tutorial/lets-begin/","text":"Welcome to the hlb tutorial! In this tutorial, we will write a hlb program to fetch the node_modules of a node project. Along the way, you will learn the basics of creating and debugging a build graph. If you ever get stuck at any point of the tutorial, feel free to clone hlb-tutorial to get a complete working example. Defining a function \u00b6 Let's start by creating a new directory and a file node.hlb . This is where we will write our hlb program. We will begin by defining a function which will become our target to build later. 1 2 3 fs npmInstall () { image \"node:alpine\" } A function begins with a return type , an identifier , an optional list of arguments , and then followed by a body enclosed in braces. The body must be non-empty, and in this example we are starting from a filesystem of a Docker image node:alpine . Since we haven't executed anything, we aren't done yet. Let's add a few more instructions to complete our program: 1 2 3 4 5 6 7 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" } If you are thinking, \"Hey, that looks like Dockerfile!\", then you would be right! hlb is a superset of the features from Dockerfiles, but designed to leverage the full power of BuildKit. Let's go over what we did. Fetched git using alpine's package manager apk Cloned a simple node project from stash Changed the current working directory to /src Run npm install , which should produce a directory at /src/node_modules containing all the dependencies for the node project When you are ready, save the node.hlb file and run the build by using the hlb binary we previously installed. hlb run --target npmInstall node.hlb You generated a node_modules directory, but since nothing was exported it is still with the BuildKit daemon. Of course, that is what we will be learning next. Exporting a directory \u00b6 Now that our build graph produces a /src/node_modules , one thing we might want to do is to export it to our system. However, if we export the target npmInstall , we'll not only get the node_modules directory, but also the rest of the alpine filesystem. In order to isolate the directory we want, we need to copy it to a new filesystem. 1 2 3 4 fs nodeModules () { scratch copy npmInstall \"/src/node_modules\" \"/\" } As we learned earlier, we can define functions which we can later target when running the build. In this new function, we are starting from a scratch filesystem (an empty one), and then copying the /src/node_modules from npmInstall . Since hlb is a functional language, variables and functions cannot be modified dynamically. When we copy from npmInstall , it is always referring to a snapshot of its filesystem after all its instructions have been executed. If we want to modify npmInstall , we will have to write a new function that starts from npmInstall but it will have to be defined with a new identifier. Now that we have isolated the directory, we can download the filesystem (containing only the node_modules ) by specifying --download <dest-dir> : hlb run --target nodeModules --download . node.hlb After the build have finished, you should see the node_modules in your working directory. $ ls node_modules node.hlb $ tree node_modules | tail -n 1 307 directories, 4014 files $ rm -rf node_modules Once you have verified the directory is correct, remove it so we can keep our workspace clean. Not just to produce images Although we are running a containerized build, it doesn't have to result in a container image. We can leverage the sandboxed environment in containers as a way to have a repeatable workflow. Going further \u00b6 Well done! We've now defined two functions npmInstall and nodeModules in our hlb program, and we've successfully downloaded just the node_modules directory to our system. We can still run npmInstall independently, because unused nodes in the build graph will be pruned if they're not a dependency of the target. If you've noticed, we didn't explicitly declare that npmInstall must be run before nodeModules . The superpower of hlb comes from the implicit build graph constructed by the instructions that invoke other functions. You don't need to think about what is safe to parallelize, and the more you decompose your build into smaller functions, the more concurrent your build! However, what we achieved so far is also possible with multi-stage Dockerfiles today. In the next chapter, we'll find out about hidden powers in BuildKit which we can start using in hlb .","title":"Let's begin!"},{"location":"tutorial/lets-begin/#defining-a-function","text":"Let's start by creating a new directory and a file node.hlb . This is where we will write our hlb program. We will begin by defining a function which will become our target to build later. 1 2 3 fs npmInstall () { image \"node:alpine\" } A function begins with a return type , an identifier , an optional list of arguments , and then followed by a body enclosed in braces. The body must be non-empty, and in this example we are starting from a filesystem of a Docker image node:alpine . Since we haven't executed anything, we aren't done yet. Let's add a few more instructions to complete our program: 1 2 3 4 5 6 7 fs npmInstall () { image \"node:alpine\" run \"apk add -U git\" run \"git clone https://github.com/left-pad/left-pad.git /src\" dir \"/src\" run \"npm install\" } If you are thinking, \"Hey, that looks like Dockerfile!\", then you would be right! hlb is a superset of the features from Dockerfiles, but designed to leverage the full power of BuildKit. Let's go over what we did. Fetched git using alpine's package manager apk Cloned a simple node project from stash Changed the current working directory to /src Run npm install , which should produce a directory at /src/node_modules containing all the dependencies for the node project When you are ready, save the node.hlb file and run the build by using the hlb binary we previously installed. hlb run --target npmInstall node.hlb You generated a node_modules directory, but since nothing was exported it is still with the BuildKit daemon. Of course, that is what we will be learning next.","title":"Defining a function"},{"location":"tutorial/lets-begin/#exporting-a-directory","text":"Now that our build graph produces a /src/node_modules , one thing we might want to do is to export it to our system. However, if we export the target npmInstall , we'll not only get the node_modules directory, but also the rest of the alpine filesystem. In order to isolate the directory we want, we need to copy it to a new filesystem. 1 2 3 4 fs nodeModules () { scratch copy npmInstall \"/src/node_modules\" \"/\" } As we learned earlier, we can define functions which we can later target when running the build. In this new function, we are starting from a scratch filesystem (an empty one), and then copying the /src/node_modules from npmInstall . Since hlb is a functional language, variables and functions cannot be modified dynamically. When we copy from npmInstall , it is always referring to a snapshot of its filesystem after all its instructions have been executed. If we want to modify npmInstall , we will have to write a new function that starts from npmInstall but it will have to be defined with a new identifier. Now that we have isolated the directory, we can download the filesystem (containing only the node_modules ) by specifying --download <dest-dir> : hlb run --target nodeModules --download . node.hlb After the build have finished, you should see the node_modules in your working directory. $ ls node_modules node.hlb $ tree node_modules | tail -n 1 307 directories, 4014 files $ rm -rf node_modules Once you have verified the directory is correct, remove it so we can keep our workspace clean. Not just to produce images Although we are running a containerized build, it doesn't have to result in a container image. We can leverage the sandboxed environment in containers as a way to have a repeatable workflow.","title":"Exporting a directory"},{"location":"tutorial/lets-begin/#going-further","text":"Well done! We've now defined two functions npmInstall and nodeModules in our hlb program, and we've successfully downloaded just the node_modules directory to our system. We can still run npmInstall independently, because unused nodes in the build graph will be pruned if they're not a dependency of the target. If you've noticed, we didn't explicitly declare that npmInstall must be run before nodeModules . The superpower of hlb comes from the implicit build graph constructed by the instructions that invoke other functions. You don't need to think about what is safe to parallelize, and the more you decompose your build into smaller functions, the more concurrent your build! However, what we achieved so far is also possible with multi-stage Dockerfiles today. In the next chapter, we'll find out about hidden powers in BuildKit which we can start using in hlb .","title":"Going further"}]}